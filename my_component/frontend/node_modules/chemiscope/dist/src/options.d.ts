/**
 * @packageDocumentation
 * @module utils
 */
import { Settings } from './dataset';
/**
 * Possible HTML attributes to attach to a setting
 */
declare type Attribute = 'value' | 'checked' | 'innerText';
interface OptionsTypeMap {
    string: [string];
    int: [number];
    number: [number];
    boolean: [boolean];
}
declare type OptionsType = keyof OptionsTypeMap;
declare type OptionsValue<T extends OptionsType> = OptionsTypeMap[T][0];
/** Possible origins of a option change: from JS code, or from DOM interaction */
export declare type OptionModificationOrigin = 'JS' | 'DOM';
/**
 * Creates a validating function that checks value against a list of valid
 * entries. This is intended to be used as a `validate` callback on an
 * [[HTMLOption]].
 *
 * @param  valid list of valid values for the setting
 * @param  name  name of the setting for better error messages
 * @return       a function that can be used to validate a new setting value
 */
export declare function optionValidator(valid: string[], name?: string): (value: string) => void;
/**
 * Simple two-way data binding implementation to store settings in chemiscope.
 *
 * This class manages a setting single value, and bind it to HTML elements.
 * Whenever the value is changed from javascript code, or updated in any of the
 * linked HTML element, it is automatically updated everywhere.
 */
export declare class HTMLOption<T extends OptionsType> {
    /** the type of the value stored by this setting */
    readonly type: T;
    /** Callback to validate the new value before propagating changes. */
    validate: (value: OptionsValue<T>) => void;
    /** Additional callbacks to run whenever the setting value changes */
    onchange: Array<(value: OptionsValue<T>, origin: OptionModificationOrigin) => void>;
    private _value;
    private _boundList;
    private _previous_value;
    /**
     * Create a new [[HTMLOption]] containing a value of the given type.
     * Possible type/values combinations are described in the [[OptionsTypeMap]]
     * interface.
     *
     * @param type  type of the setting
     * @param value initial value of the setting
     */
    constructor(type: T, value: OptionsValue<T>);
    /** Get the value of this setting */
    get value(): OptionsValue<T>;
    /** Set a new value for this setting */
    set value(v: OptionsValue<T>);
    /**
     * Call all onchange callbacks & update the DOM representation after a
     * change. This function is called automatically when using `.value = ...`
     */
    changed(origin: OptionModificationOrigin): void;
    /** Reset to a previous value for this setting */
    reset(): void;
    /**
     * Add a new HTML element to the list of synchronized element.
     * `element.attribute` will be set to the setting value, and the setting
     * value will be updated every time the 'change' event is sent.
     *
     * @param  element   HTML DOM element to watch for updates, or string id
     *                   of such element
     * @param  attribute attribute of the HTML element to use as value
     */
    bind(element: HTMLElement | string, attribute: Attribute): void;
    /**
     * Disable all HTML elements linked to this by setting the `disabled`
     * attribute to `true` if it exists on the element. This should only
     * disable HTMLInputElement.
     */
    disable(): void;
    /**
     * Enable all HTML elements linked to this by setting the `disabled`
     * attribute to `false` if it exists on the element. This should only
     * enable HTMLInputElement.
     */
    enable(): void;
    /**
     * Remove all HTML elements bound to this setting, and the associated event
     * listeners.
     */
    unbindAll(): void;
    private _update;
}
/**
 * Callback function to use with [[OptionsGroup.foreachSetting]]
 */
export declare type OptionsCallback = (keys: string[], setting: HTMLOption<any>) => void;
/**
 * Abstract base class to use for a group of settings.
 *
 * This class implement saving current settings as [[SavedSettings]]; and
 * applying saved settings to the setting group.
 *
 * # Example
 *
 * ```typescript
 * class MyOptions extends OptionsGroup {
 *     public cats: HTMLOption<'int'>;
 *     public dogs: {
 *          husky: HTMLOption<'string'>;
 *          labrador: HTMLOption<'string'>;
 *     };
 *
 *     constructor() {
 *         super();
 *         this.cats = new HTMLOption('int', 3);
 *         this.dogs = {
 *             husky: new HTMLOption('string', 'a cold dog'),
 *             labrador: new HTMLOption('string', 'a long dog'),
 *         };
 *     }
 * }
 *
 * const settings = new MyOptions();
 *
 * settings.saveSettings();
 * // {cats: 3, dogs: {husky: 'a cold dog', labrador: 'a long dog'}}
 *
 * settings.applySettings({cats: 66, dogs: {husky: 'a good dog'}});
 * settings.saveSettings();
 * // {cats: 66, dogs: {husky: 'a good dog', labrador: 'a long dog'}}
 * ```
 */
export declare abstract class OptionsGroup {
    /**
     * Save the current values of all HTMLOption properties of the class,
     * including nested ones.
     *
     * Properties which name starts with an underscore are ignored.
     *
     * @return An object with the same structure as this class containing the
     *         values of all settings.
     */
    saveSettings(): Settings;
    /**
     * Set values from `settings` to the [[HTMLOption]] properties of this class,
     * matching the properties names.
     *
     * Properties starting with an underscore are ignored.
     */
    applySettings(settings: Settings): void;
    /**
     * Add the given `callback` to be called whenever a setting changes. The
     * callback will be given the path to the settings as a list of keys; and
     * the new value of the setting.
     *
     * There is currently no way to remove a callback.
     */
    onSettingChange(callback: (keys: string[], value: unknown) => void): void;
    /**
     * Call the given callback on each setting inside the given SettingGroup.
     *
     * Keys starting with an underscore character are ignored.
     *
     * @param settings group of settings
     * @param callback callback operating on a single setting
     */
    protected foreachOption(callback: OptionsCallback): void;
}
export {};
